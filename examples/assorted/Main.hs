#!/usr/bin/env runhaskell
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -fno-cse #-}

module Main where

import Control.Applicative
import Control.Concurrent
import Control.Concurrent.FairRWLock as FairRWLock
import Control.Concurrent.MSampleVar as MSampleVar
import Control.Concurrent.MSem       as MSem
import Control.Concurrent.MSemN      as MSemN
import Control.Concurrent.STM
import Control.Monad
import Data.Global
import Text.Printf

-- | Calling thread sleeps (GHC only)
sleepSeconds :: Integer -> IO ()
sleepSeconds = threadDelay . fromIntegral . (* 1000000)

un "numChildProcessesAvailable" =:: ([| 3 :: QSemQuantity |], ut [t| () |] :: UT (Const QSemN))

-- | Alias to 'numChildProcessesAvailable'
numChildren :: QSemN
numChildren = numChildProcessesAvailable

un "sample" =:: (uninitialized, ut [t| () |] :: UT (UDEmpty SampleVar))
un "sample2" =:: ([| () |], ut [t| () |] :: UT SampleVar)

un "channel" =:: (uninitialized, ut [t| String |] :: UT (UDEmpty MSampleVar))

-- | Part from the currently joined channel.  If there is no channel, do nothing
dropChannel :: IO ()
dropChannel = do
    emptySV channel
    putStrLn $ printf "no longer in channel"

-- | Go to a channel; bring it to focus; backlog is downloaded if necessary.  If a channel is already in focus
gotoChannel :: String -> IO ()
gotoChannel name = do
    writeSV channel name
    putStrLn $ printf "joined '%s'" name

un "le_file_contents" =:: ([|
    "# AUTOMATICALLY GENERATED BY FOO DO NOT MODIFY FILE BY HAND OR OTHER\n"
 ++ "# PREHENSILE IF YOU DON'T KNOW WHAT YOU'RE DOING (which would be\n"
 ++ "# modifying the file by hand or other prehensile) OR ELES BAR WILL\n"
 ++ "# SUPPORT antidisestablishmentarianism, WHICH IS BAD BECAUSE\n"
 ++ "# antidisestablishmentarianism IS BAD FOR BAR\n"
    |], ut [t| String |] :: UT MSampleVar)
un "le_file_lock" =:: (uninitialized, ut [t| () |] :: UT (Const RWLock))

-- | Write to file in a new thread
fileWrite :: String -> IO ()
fileWrite s = do
    withWrite le_file_lock $ do
        writeSV le_file_contents s

-- | Read and remove file
fileReadAndRemove :: IO String
fileReadAndRemove = withRead le_file_lock $ do
    readSV le_file_contents

-- | Read file and write an appended version; defined in terms of fileWrite and fileReadAndRemove
--
-- Will wait for input if the file doesn't exist
fileAppend :: String -> IO ()
fileAppend s = fileReadAndRemove >>= \contents -> fileWrite $ contents ++ s

un "a_very_meaningless_example" =:: ([| 2 :: Integer |], ut [t| Integer |] :: UT MSem)
un "a_quite_meaningless_example" =:: ([| 2 :: Integer |], ut [t| Integer |] :: UT MSemN)

un "tvar" =:: ([| [[]] |], ut [t| [[[[[[()]]]]]] |] :: UT TVar)
un "tmvar" =:: ([| "" |], ut [t| String |] :: UT TMVar)
un "tmvar2" =:: (uninitialized, ut [t| String |] :: UT (UDEmpty TMVar))
un "tchan" =:: ([| () |], ut [t| String |] :: UT (UDEmpty TChan))

-- Normally, this would be split into multiple actions.
main :: IO ()
main = do
    -- Start two individual processes, independent of each other
    waitQSemN numChildren 1 >> putStrLn "A starts"
    waitQSemN numChildren 1 >> putStrLn "B starts"

    -- Write 
    writeSampleVar sample ()
    writeSampleVar sample ()
    writeSampleVar sample ()
    writeSampleVar sample ()
    -- ^ Since it's a SampleVar, when it's full, this thread won't block; the value will be overwriting instead

    -- Start two mutually dependant processes who communicate with each other
    void . forkIO $ do
        waitQSemN numChildren 2  -- C, D
        putStrLn $ printf "C and D started"
    sleepSeconds 1

    -- Take sample
    readSampleVar sample
    -- The sample variable is now empty; reading from it again will cause the thread to block since it is now empty

    signalQSemN numChildren 1 >> putStrLn "A finishes"
    signalQSemN numChildren 1 >> putStrLn "C finishes"
    signalQSemN numChildren 1 >> putStrLn "D finishes"
    writeSampleVar sample2 ()  -- (Doesn't block)
    signalQSemN numChildren 1 >> putStrLn "B finishes"

    gotoChannel "#haskell"
    gotoChannel "#lojban"
    dropChannel
    dropChannel
    dropChannel
    gotoChannel "##categorytheory"
    dropChannel
    gotoChannel "#agda"
    gotoChannel "#bitcoin"
    gotoChannel "#bitcoin-otc-foyer"

    sleepSeconds 3

    --

    let pTheContentsAndRemove = putStrLn . printf "Contents of file: '%s'" =<< fileReadAndRemove

    pTheContentsAndRemove
    fileWrite ""
    pTheContentsAndRemove
    fileWrite "A line\n"
    pTheContentsAndRemove
    fileWrite "A line\n"
    fileAppend "Another line\n"
    pTheContentsAndRemove
    fileWrite "A new line\n"
    pTheContentsAndRemove

    --

    void . forkIO $ do
        MSem.with a_very_meaningless_example $ do
            print "coi"
    void . forkIO $ do
        MSem.with a_very_meaningless_example $ do
            print "coi"
    void . forkIO $ do
        MSemN.with a_quite_meaningless_example 2 $ do
            print "coi"
            print "coi"

    --

    atomically $ do
        writeTVar tvar [[[[[[]]]]]]
        void $ takeTMVar tmvar
        putTMVar tmvar ".i .ua zo'e cu co'e do'e zo'e vau .ausai"
        putTMVar tmvar2 ".i loka mintu cu me ri ri"
        writeTChan tchan ".i lo za'i cfipu vo'a djica dei gleki cu'u la xalbo"

    putStrLn . printf "tchan: '%s'" =<< show <$> atomically (readTChan tchan)

    --

    -- Atrocious means of waiting for other threads to finish
    sleepSeconds 5
